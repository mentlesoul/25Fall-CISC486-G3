# CISC486 – Mini Tower Defense Demo (README)

> Unity 6 (6000.x). Scene: `Assets/MyScenes/Demo/Demo1.unity`

---

## AI Plan & FSM (This part same as relization in A2)

**Flow:** `Spawn → Repath ↔ Move → { Goal | Dead }`

### States

#### Spawn
- Initialize unit (HP, speed, drops).
- Subscribe to **GridVersion** changes.
- **Transition:** → **Repath** after the initialization freeze window (see `initFreezeSeconds`).

#### Repath
- Compute path with **A\*** (Manhattan heuristic + small turn cost; cached).
- **On success:** → **Move**  
- **On failure:** retry after a short delay (server/placement rules prevent permanent no-path).

#### Move
- Follow waypoints with speed/acceleration limits, corner smoothing, and light separation.
- **If grid/tower changes:** → **Repath**

#### Goal
- **Regular enemies:** apply Hearts damage; then despawn.  
- **Supply convoy (if present):** counts as *Escaped*; apply a stacking buff to future waves; then despawn.

#### Dead / Despawn
- **HP ≤ 0:** play death FX and drops (convoy has no Hearts damage; drops per design); then despawn.

### Transitions

- **Spawn → Repath:** after init freeze completes on unit creation.  
- **Repath → Move:** when a valid path is obtained.  
- **Move ↔ Repath:** any of:
  - **GridVersion++** (place/sell/upgrade towers),
  - Next cell becomes unwalkable/occupied,
  - Current path invalid or timed out.  
  *Debounce with ~100–200 ms jitter and a per-frame replan cap.*
- **Move → Goal:** center enters EndPoint trigger (or within goal radius as fallback).  
- **Move → Dead:** HP ≤ 0.

---

## 1) Overview

A compact 3D scene with a Player, an enemy NPC controlled by a finite state machine, a tile grid, and A* pathfinding. The enemy spawns, plans a path across the grid, walks the path, and either reaches the EndPoint or dies. Each state is clearly visible through behavior and a floating label above the enemy.

We simulated a scenario where some grids could not be passed through after placing defense towers. And manually refresh the cache path(But in reality, this should be triggered every time a defense tower is built or dismantled). It can be seen that the hostile unit NPC will spawn from the random grid in the Spawn Area and follow the cache path to the Base Area.

---

## 2) New System

We have designed a surface design framework that is very convenient to use presets and drag-and-drop placement operations. Meanwhile, the presets will be automatically adsorbed into the grid. The size of the grid depends on the config of the MainGround, and the grid occupied by the presets for n\*n depends on the config of itself. By default, the world grid size is 1\*1 preset side length, and each preset is defaulted to 2\*2 buildable grids side length. This means that when the default size, each preset grid has 2*2, that is, 4 grids available to build tower.

Meanwhile, we have developed an algorithm based on the automatic recognition of preset components and the automatic recognition of buildable grids. And an restructured A* pathfinding algorithm that only moves up, down, left and right based on those automatically recognited buildable grids.

This pathfinding system was supposed to refresh the cache in conjunction with the building and dismantling mechanism in the game. However, for debugging purposes, we deliberately left a manual cache refresh button in the LevelConfig object. And in the editor view, the path visibility can be manually opened.

---

## 3) How to Run

1. Open the project in Unity 6 and load `Demo1.unity`.
2. Press **Play**. You will see the full cycle log in console: Initialization → Pathfinding → Following path → Goal/Dead.

---
